<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[用axis开发服务端和客户端]]></title>
      <url>%2F2016%2F12%2F21%2Fpage_6%2F</url>
      <content type="text"><![CDATA[第一种方式1.导入axis jar包2.右键项目，Run As , Run Configurations , new一个Java Application , 点击search , 选择wsdl2java , 勾选第一个复选框。3.点击Argumnets , 在Program arguments内输入以下内容（服务端：-t -s wsdl文件路径 -o 输出目录，客户端：-t wsdl文件路径 -o 输出目录）-t：生成junit测试用例-s：生成服务端代码-o：代码输出目录 4.点击Apply, 点击run, 刷新项目，即在此项目下根据wsdl文件生成了服务端或客户端代码。 5.根据wsdl文件生成服务端或客户端后：（1）客户端测试类： public static void main(String[] args) throws ServiceException { xxxxx_ServiceLocator serviceLocator = new xxxxx_ServiceLocator(); xxxxx_PortType service = serviceLocator.getxxxxx(); service.xxxxxx(); } 或者在junit的TestCase中测试。 （2）服务端具体实现类写在###########SoapBindingImpl类中 第二种方式写一个.bat文件服务端： set Axis_Lib=D:\Axis\axis-bin-1_4\axis-1_4\lib set Java_Cmd=java -Djava.ext.dirs=%Axis_Lib% set Output_Path=C:\Users\xxxx\Desktop\axis-client %Java_Cmd% org.apache.axis.wsdl.WSDL2Java -o%Output_Path% C:\Users\xxxx\Desktop\wsdl\xxxxx.wsdl -s -t 客户端： set Axis_Lib=D:\Axis\axis-bin-1_4\axis-1_4\lib set Java_Cmd=java -Djava.ext.dirs=%Axis_Lib% set Output_Path=C:\Users\xxxx\Desktop\axis-client %Java_Cmd% org.apache.axis.wsdl.WSDL2Java -o%Output_Path% C:\Users\xxxx\Desktop\wsdl\xxxx.wsdl -t Axis_Lib：axis jar包路径。output_path：代码输出路径。 服务端生成后，新建server-config.xml，复制deploy.xml内容至其中。 xsd文件生成java类：1.把xsd文件复制到项目下。2.右击xsd文件，选择Generate，JAXB Classes3.选择Source folder，Package4.next到finish。 备注：服务端多值返回可以用StringHolder对象来处理，用StringHolder.value()获取值。比如：服务端返回errorCode和errorMsg时，请求参数和返回参数写在一起，返回void。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用cxf开发服务端和客户端]]></title>
      <url>%2F2016%2F12%2F21%2Fpage_5%2F</url>
      <content type="text"><![CDATA[服务端开发的实现1.打开命令行操作界面，进入到cxf\bin目录下，输入wsdl2java –server –impl wsdl的完整文件名，点击回车键，即生成了webservice服务端程序。D:\apache-cxf-2.2.4\bin&gt;wsdl2java -server -impl xxxxxx.wsdl 2.导入cxf的jar包3.在src目录下建立一个ApplicationContext.xml文件，输入以下内容：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:cxf=&quot;http://cxf.apache.org/core&quot; xmlns:soap=&quot;http://cxf.apache.org/bindings/soap&quot; xmlns:jaxws=&quot;http://cxf.apache.org/jaxws&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsd http://cxf.apache.org/core http://cxf.apache.org/schemas/core.xsd http://cxf.apache.org/bindings/soap http://cxf.apache.org/schema/bindings/soap.xsd http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd&quot;&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf.xml&quot; /&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-soap.xml&quot; /&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-local.xml&quot; /&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf-extension-http.xml&quot; /&gt; &lt;import resource=&quot;classpath:META-INF/cxf/cxf-servlet.xml&quot; /&gt; &lt;!-- CIMCardAgreementService HTTP --&gt; &lt;jaxws:endpoint id=&quot;CIMCardAgreementService&quot; implementor=&quot;com.bankcomm.pccc.service.cim.abstraction.atomic.pccc_cim_cimcardagreement.v1.CIMCardAgreementImpl&quot; address=&quot;/CIMCardAgreementService&quot;&gt; &lt;/jaxws:endpoint&gt; &lt;/beans&gt; 其中id属性值依据具体的服务来决定，implementor属性值应填入：服务实现类的完整的包名加上类名，address属性值填入服务发布的相对地址，依据具体服务来决定 4.找到实现类的注释部分，将wsdlLocation = “”一段注释删除5.找到工程的web.xml，输入以下内容&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app id=&quot;WebApp_ID&quot; version=&quot;2.4&quot; xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;&gt; &lt;display-name&gt;loanAcctMaintainServiceServer&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:ApplicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.cxf.transport.servlet.CXFServlet&lt;/servlet-class&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;CXFServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/WS/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 6.将服务部署到服务器上运行在浏览器的地址栏中输入http://服务器的IP：服务器上端口号/工程名/WS/，点击回车，查看。 客户端开发实现1.打开命令行操作界面，进入到cxf\bin目录下，输入wsdl2java –client wsdl的完整文件名，点击回车键，即生成了webservice客户端程序。D:\apache-cxf-2.2.4\bin&gt;wsdl2java -client xxxxxx.wsdl 2.导入cxf的jar包3.编写客户端调用类]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git和svn的区别]]></title>
      <url>%2F2016%2F12%2F20%2Fpage_4%2F</url>
      <content type="text"><![CDATA[1）Git是分布式的，SVN不是：这是git和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。好处是跟其他同事不会有太多的冲突，自己写的代码放在自己电脑上，一段时间后再提交、合并，也可以不用联网在本地提交。git跟SVN一样有自己的集中式版本库或服务器。但git更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。可以这样说，如果你被困在一个不能连接网络的地方时，你仍然能够提交文件，查看历史版本记录，创建项目分支等。 2）git把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。因为.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。 3）git没有一个全局的版本号，而SVN有4）git分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。然而，处理git的分支却是相当的简单和有趣。 5）git的内容完整性要优于SVN：git的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。 6）git下载下来后，在本地不必联网就可以看到所有的log，很方便学习，SVN却需要联网；7）SVN在Commit前，我们都建议是先Update一下，跟本地的代码编译没问题，并确保开发的功能正常后再提交，git可能这种情况会少些。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何美化Github Pages搭建的独立博客]]></title>
      <url>%2F2016%2F12%2F20%2Fpage_3%2F</url>
      <content type="text"><![CDATA[一、进入Hexo的官网主题专栏二、挑选我们喜欢的主题可以看到有很多主题给我们选，我们只要选择喜欢的主题点击进去，然后进入到它的github地址，我们只要把这个地址复制下来(例如我是选择：hexo-theme-next这个主题) 三、克隆主题再打开Hexo文件夹下的themes目录，右键Git Bash，在命令行输入: git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 之后主题下载中，等待下载完成。 四、修改Hexo配置文件下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: hexo-theme-next 五、部署主题，本地查看效果返回Hexo目录，右键Git Bash，输入 hexo g hexo s 打开浏览器，输入 http://localhost:4000/ 即可看见我们的主题已经更换了。 六、如果效果满意，将它部署到Github上打开Hexo文件夹，右键Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题) hexo g -d 七、打开自己的主页，即可看到修改后的效果更多修改效果请查看对应主题的说明文档。 查看本主题（next）对应的说明文档，请点击http://theme-next.iissnan.com/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用Github Pages搭建独立博客简明教程]]></title>
      <url>%2F2016%2F12%2F20%2Fpage_2%2F</url>
      <content type="text"><![CDATA[一、安装node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装,不需要配置环境变量。 二、安装Git安装完后，右键点击Git Bash Here即可打开Git Shell。 Git基本操作git clone：将远程仓库复制到本地：git clone 项目地址git init：新建一个仓库。git pull：抓取远程仓库搜有分支更新合并到本地。git add：跟踪新文件（把目标文件快件放入暂存区域）：git add 文件名/文件夹名，如果是跟踪全部修改过的文件：git add或者git add –allgit commit：提交你的修改：git commit -m “你的注释”git push：推送你本地仓库的更新到远程仓库，语法为git push [远程名] [本地分支]：[远程分支] 三、Hexo桌面右键鼠标，点击Git Bash Here，输入npm命令即可安装 npm install hexo-cli -g npm install hexo --save 如果命令无法运行，可尝试更换taobao的npm源 npm install -g cnpm --registry==https://registry.npm.taobao.org Hexo初始化配置创建Hexo文件夹安装完成后，新建目录如：F:\Blog\Hexo，进入文件夹右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。 hexo init npm install 安装完成后，Hexo将会在指定文件夹中新建所需的文件。 安装Hexo插件以下是Hexo的其他插件（进入Hexo文件夹） npm install hexo-generator-index --save npm install hexo-generator-archive --save npm install hexo-generator-category --save npm install hexo-generator-tag --save npm install hexo-server --save npm install hexo-deployer-git --save npm install hexo-deployer-heroku --save npm install hexo-deployer-rsync --save npm install hexo-deployer-openshift --save npm install hexo-renderer-marked@0.2 --save npm install hexo-renderer-stylus@0.2 --save npm install hexo-generator-feed@1 --save npm install hexo-generator-sitemap@1 --save 本地查看效果进入Hexo文件夹并执行下面语句，执行完即可登录localhost:4000查看效果。 hexo g hexo s 将博客部署到Github Pages上第一步、注册Github账号第二步、创建项目代码库注册完成后，创建一个Github Pages项目，点击New repository。 创建注意要点：1.Repository name 项目名称必须为username.github.io 2.选择Public 3.勾选Initialize this repository with a README。最后点击创建。 第三步、配置SSH密钥配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码与Github代码库的同步。 1.查看是否存在SSH密钥首先查看本机是否存在SSH keys，打开Git Bash，并运行。 cd ~/.ssh 检查本机用户home目录下是否存在.ssh目录，如果不存在此目录，则进行第二步操作，否则，本机已经存在ssh公钥和私钥，直接进行第三步操作。 2.创建一对新的SSH密钥 ssh-keygen -t rsa -C &quot;邮箱地址&quot; 之后将会按照提供的邮箱地址，创建一对密钥，如下提示。 Generating public/private rsa key pair. Enter file in which to save the key(/c/Users/you/.ssh/id_rsa):[Press enter] 直接回车，则将密钥按照默认文件进行存储。也可以输入特定的文件名，如：/c/Users/you/.ssh/github_rsa,接着，根据提示，输入密码和确认密码。 Enter passphrase (empty for no passphrase): [Type a passphrase] Enter same passphrase again: [Type passphrase again] 输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa. Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub. The key fingerprint is: 01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 3.在Github账户中添加公钥登录Github，进入Account Settings，选择SSH keys，粘贴密钥。 4.测试可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： $ ssh -T git@github.com 如果是下面的反馈： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? 输入yes，将会看到。 Hi cnfeat! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 5.设置用户信息现在你已经可以通过SSH连接到GitHub了，还有一些个人信息需要完善的。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理。 $ git config --global user.name &quot;cnfeat&quot;//用户名 $ git config --global user.email &quot;cnfeat@gmail.com&quot;//填写自己的邮箱 6.SSH key配置成功本机已成功连接到github。 第四步、将本地的Hexo文件更新到Github的库中1.登录Github打开自己的项目username.github.io，复制项目地址。 2.打开本地Hexo文件夹，修改文件夹下的_config.yml文件 deploy: type: git repository: &quot;填写刚才复制的项目地址&quot; branch: master 3.在Hexo文件夹下执行： hexo g hexo d 或者直接执行 hexo g -d 执行完之后会让你输入github的账号和密码，输入完后就可以登录我们自己的部署在Github Pages服务器上的博客了。对应的地址是 username.github.io。 4.在浏览器上输入自己的主页地址，即可看到自己的博客了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何用Github Pages+Hexo+Markdown搭建一个独立博客（前言）]]></title>
      <url>%2F2016%2F12%2F18%2Fpage_1%2F</url>
      <content type="text"><![CDATA[欢迎大家来到我的博客， 这个博客非常有意思哦。。。 摘要：Github Pages和Hexo可以用于搭建自己的独立博客，本篇博客主要对Github Pages和Hexo进行简单的介绍。 关于GithubGithub的优点 GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。 GitHub可以免费使用，并且快速稳定。 Github上面的世界很精彩，用久了你的眼界会开阔很多。 什么是Github PagesGithub Pages可以被认为是用户编写的、托管在github上的静态网页。 为什么要使用Github Pages 可以绑定你的域名(但暂时貌似只能绑定一个)。 简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 关于HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 用Markdown写文章什么是Markdown？Markdown 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。 Markdown有什么优点？ 专注你的文字内容而不是排版样式。 轻松的导出 HTML、PDF 和本身的 .md 文件。 纯文本内容，兼容所有的文本编辑器与字处理软件。 可读，直观。适合所有人的写作语言。 我该用什么工具？ Windows下可以使用 MarkdownPad2。 在 Mac OS X 上，我建议你用 Mou 这款免费且十分好用的 Markdown 编辑器。 Web 端上，我强烈推荐 简书 这款产品。]]></content>
    </entry>

    
  
  
</search>
